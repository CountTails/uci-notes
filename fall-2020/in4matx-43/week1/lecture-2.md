# Lecture 2: What is software engineering?

## Perspectives on software engineering

### Shawna, CEO (Business)

- What matters most? 
    - Cost
    - Time 
    - Profit
- How does software engineering help?
    - Keep cost low in development
    - Usable and valuable software brings profit

### Andy, Software engineer (Internal)

- What matters most?
    - Internal quality (not seen by users)
    - Design of software
        - Reusability
        - Readability
        - Understandability
- How does software engineering help?
    - Offers techniques for quality assurance

### Clara, Working mother (User)

- What matters most?
    - External quality (all the user sees)
    - User experience
- How does software engineering help?
    - Developing usable software

## Essential ingredients

- People: Do the work
- Processes: Organize and manage people
- Tools: Support the work done

## Software principles

### Davis (1994)

- Make quality number 1
- Give products to customers early
- Understand the problem first
- Choose appropriate processes
- Good management > good technology
- People are the key to success

### Wasserman (1996)

- Modularity
- Abstraction
- User interface prototyping
- Reuse
- Metrics

### Royce (1998)

- Follow an architecture-first process
- Use component-based development (buy > build)
- Show customers preliminary versions frequently
- Have incremental releases

### In4matx 43

- Rigor and formality
- Separation of concerns
    - Modularity
    - Divide and conquer
    - Abstraction
- Anticipation of change
- Generality
- Incrementality

## No silver bullet

### Properties of software

- Complexity: a construct of interlocking concepts (data structures, classes, algorithms and functions)
- Conformity: system must conform to human institutions
- Changeability: must be easy to make changes to the software
- Invisibility: software is not inherently embedded in space

### False silver bullets

- High-level languages
- Time sharing
- Unified programming environments
- Object-oriented programming
- Artificial intelligence
- Expert systems
- Automatic / graphical programming
- Program verification
- Environments / tools
- Workstations

### Potential silver bullets

- Buy vs. build
- Requirement refinement and rapid prototyping
- Incremental development
- Great designs